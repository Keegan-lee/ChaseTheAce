pragma solidity ^0.5.0;

import "./Raffle.sol";

/// @title  A contract that facilitates the playing of Chase The Ace
/// @author Keegan Lee Francis keegan@atlantic-blockchain.com
/// @notice In general, this contract keeps track of, and controls interaction with 3 things (Deck of Cards, Raffles, Jackpot)
/// @dev    This contract uses a commit/reveal for each round of raffle that goes by. At the end of every raffle, the winner gets to "select" a random card from the deck. That random number is generated by using a commit/reveal provided by the winner, and the owner.
contract ChaseTheAce {
  // The owner of the game
  address payable owner;

  // The number of cards in a deck
  uint constant public NUMBER_OF_CARDS = 52;

  // Keep track of the cards that were picked
  uint[] public picks;

  // Keep track of each of the raffles
  Raffle[] public raffles;

  // Keep track of the current raffle
  uint public currentRaffle;

  // Each round of ChaseTheAce involves a commit/reveal scheme
  PlayerCommit[] public playerCommits;
  PlayerCommit[] private ownerCommits;

  // The winner of the game
  address payable public winner;
  bool public winningsClaimed;

  // The jackpot
  uint public jackpot;

  struct PlayerCommit {
    address payable committer;
    bytes32 commit;
    uint256 reveal;
    bool revealed;
  }

  /// @notice Creates and initializes a game of Chase The Ace
  /// @param _owner The owner of the game
  constructor(
    address payable _owner
  ) public {
    owner = _owner;

    // The winnings of the game have not been claimed by default
    winningsClaimed = false;

    // Initialze the jackpot to 0
    jackpot = 0;
  }

  /// @notice This function creates, and pushes a new raffle into the raffle array
  /// @param contractOwner  The owner of the raffle, usually the owner of ChaseTheAce game
  /// @param ticketPrice    The price of each raffle ticket
  /// @param commit         Initialize the raffle with a secret number, to be revealed later for pseudo randomness
  /// @param revealsNeeded  How many player reveals are needed before the winning ticket is picked
  /// @param raffleCut      (2 = 50%, 3 = 33%) What cut does the raffle receive of the money raised?
  /// @param revealRefund   How much of a refund does the player receive for revealing their commit
  function newRaffle(
    address payable contractOwner,
    uint ticketPrice,
    bytes32 commit,
    uint revealsNeeded,
    uint raffleCut,
    uint revealRefund
  )
  public
  currentRaffleEnded
  hasFinishedPick
  {
    raffles.push(
      new Raffle({
        _owner: contractOwner,
        _chaseTheAceAddress: address(uint160(address(this))),
        _ticketPrice: ticketPrice,
        _commit: commit,
        _revealsNeeded: revealsNeeded,
        _raffleCut: raffleCut,
        _revealRefund: revealRefund
      })
    );

    // Set the current raffle to the index of the last raffle in the array
    currentRaffle = raffles.length - 1;
    emit NewRaffle(address(raffles[currentRaffle]), currentRaffle);
  }

  /// @notice This function is called after the currentRaffle has ended, in order to properly seed a random number to pick a card from the deck
  /// @param  _commit   The winner of the current raffles commit ( to pick a "random" card from the deck). _commit is a hash of a uint.
  function playerCommit(bytes32 _commit)
  public
  currentRaffleEnded
  isWinnerOfRaffle
  {
    playerCommits.push(PlayerCommit(msg.sender, _commit, 0, false));
  }

  /// @notice This function pairs with the playerCommit function to just reveal the commit
  /// @param  _reveal The uint that was used to generate the hash of the commit
  /// @dev    The getHash(_reveal)
  function playerReveal(uint _reveal)
  public
  currentRaffleEnded
  isWinnerOfRaffle
  hasCommitted
  otherHasCommitted
  revealMatch(_reveal)
  {
    playerCommits[currentRaffle].reveal = _reveal;
    playerCommits[currentRaffle].revealed = true;
  }

  /// @notice After each chase the ace round, the owner needs to commit a number to ensure pseudo randomness
  /// @param _commit  The hashed number
  function ownerCommit(bytes32 _commit)
  public
  onlyOwner
  currentRaffleEnded
  {
    ownerCommits.push(PlayerCommit(msg.sender, _commit, 0, false));
  }

  /// @notice The owners reveal, which will then call the executePick function. This function can only be called after the player as revevaled their commit
  /// @param _reveal  The actual number, that when hashed, matches the commit
  function ownerReveal(uint _reveal)
  public
  onlyOwner
  currentRaffleEnded
  otherHasCommitted
  hasCommitted
  revealMatch(_reveal)
  {
    ownerCommits[currentRaffle].reveal = _reveal;
    ownerCommits[currentRaffle].revealed = true;
    executePick();
  }

  /// @notice This function uses the reveals from the owner and winner of the currentRaffle to make a random number
  /// @dev    The random number is used to select a card from the deck. 0 is the ace of spades.
  function executePick() private {
    uint pick = random();
    picks.push(pick);

    if (pick == 0) { // Win
      winner = playerCommits[currentRaffle].committer;
      emit Win(winner, jackpot);
    }

    emit NotWin();
  }

  /// @notice The withdraw function for the winner to withdraw their funds
  function claimWinnings()
  public
  payable
  notOwner
  isWinner
  hasNotClaimedWinnings
  {
    winningsClaimed = true;
    msg.sender.transfer(jackpot);
  }

  /// @notice Generates a pseudo random number
  function random() private view returns (uint) {
    return (playerCommits[currentRaffle].reveal +
            ownerCommits[currentRaffle].reveal +
            uint256(keccak256(abi.encode(block.difficulty)))) % (NUMBER_OF_CARDS - currentRaffle);
  }

  /// @notice Takes a number and gives the keccak256 hash of that number
  /// @param hashThis The number to hash
  /// @return hashed The hashed number
  function getHash(uint hashThis)
  public
  pure
  returns (bytes32 hashed) {
    return keccak256(abi.encode(hashThis));
  }

  /// @notice Make the default function payable so the contract can receive ETH
  function() external payable {}

  modifier onlyOwner() {require(msg.sender == owner, "Caller must be the owner of the contract"); _;}
  modifier notOwner() {require(msg.sender != owner, "Caller must not be the owner"); _;}
  modifier isWinner() {require(msg.sender == winner, "Caller is not the winner of the raffle."); _;}

  modifier hasNotClaimedWinnings() {require(!winningsClaimed, "Cannot claim winnings more than once"); _;}
  modifier currentRaffleEnded() {
    // Check to see if a winner has been picked from the current raffle, if there are picks in the picks array
    if (raffles.length > 0) {
      require(raffles[currentRaffle].winnerPicked(), "Current Raffle must have ended");
    }
    _;
  }

  modifier hasCommitted() {
    if (msg.sender == owner) {
      require(ownerCommits[currentRaffle].commit[0] != 0, "Owner must have submitted a commit");
    } else {
      require(playerCommits[currentRaffle].commit[0] != 0, "User must have submitted a commit");
    }
    _;
  }

  modifier otherHasCommitted() {
    if (msg.sender == owner) {
      require(playerCommits[currentRaffle].commit[0] != 0, "User must have submitted a commit before revealing.");
    } else {
      require(ownerCommits[currentRaffle].commit[0] != 0, "Owner must have submitted a commit before revealing.");
    }
    _;
  }

  modifier isWinnerOfRaffle() {
    require(
      msg.sender == raffles[currentRaffle].tickets(raffles[currentRaffle].winningTicket()),
      "Only the owner of the current raffle can submit a commit/reveal"
    );
    _;
  }

  modifier hasFinishedPick() {
    if (picks.length > 0) {
      require(picks.length == raffles.length, "Cannot start a new raffle until the winner of the previous raffle has picked a card");
    }
    _;
  }

  modifier revealMatch(uint reveal) {
    if (msg.sender == owner) {
      require(getHash(reveal) == ownerCommits[currentRaffle].commit, "Owner reveal must match commit"); _;
    } else {
      require(getHash(reveal) == playerCommits[currentRaffle].commit, "Player reveal must match commit"); _;
    }
  }

  event Win(address winner, uint jackpot);
  event NotWin();
  event NewRaffle(address raffle, uint numberOfRaffles);
}